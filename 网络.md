# 网络

## http

### 1. http123

#### Http1.0

浏览器每次请求都需要与服务器建立一个TCP连接，处理完就断开

#### Http1.1

Keep-alive 长连接

管道传输（按顺序执行）

#### Http2.0

首部压缩

二进制分帧

多路复用

- http2的传输是基于二进制帧的
- 每一个TCP连接中承载了多个双向流通的流，每一个流都有一个独一无二的标识和优先级，而流就是由二进制帧组成的。
- 二进制帧的头部信息会标识自己属于哪一个流，所以这些帧是可以交错传输，然后在接收端通过帧头的信息组装成完整的数据。

#### http3.0

基于 UDP 的 QUIC 协议。建立持久连接、协商加密协议

### 2. https握手

SSL 已经逐渐被 TLS 取代

 TLS 握手的过程中，通信双方交换消息以相互验证，相互确认，并确立它们所要使用的加密算法以及会话密钥 (用于对称加密的密钥)。

1. 客户端发送client_hello (询问) 包含了客户端所支持的 **TLS 版本**和**密码组合**以供服务器进行选择，还有一个"**client random**"随机字符串。
2. 服务端发送server_hello （返回协商信息） 该消息包含了**数字证书**，**服务器选择的密码组合**和"**server random**"随机字符串。
3. 客户端验证证书，确保对方合法身份，从中获取公钥，生成随机字符串**premaster secret**并用公钥进行加密并返回给服务端
4. 服务端使用私钥获取**premaster** **secret**，只有私钥能解密

5. 客户端服务端使用相同的算法，并使用client random  server random premaster secret生成相同的密钥key
6. 客户端发送通过key加密的finished
7. 服务端发送通过key加密的finished
8. 成功建立安全连接，用key通信

### 3. http状态码

100 请求已经被接受，需要继续处理

200 请求成功

204 无内容

- 服务器成功处理，但未返回内容

301 永久移动 （请求的资源永久移动到新的URI）

302 临时移动

304 未修改 

- 如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容自上次访问并没有改变，则服务器应当返回这个304状态码。

400 请求无效

- 前端字段名称没有与后端保持一致
- 前端没有把对象转化为json 

401

- 当前请求需要用户验证

404 没有找到资源

500 服务器错误

### 4. http常用请求头

### 5. http常用请求方法



## web socket

1. 全双工 可以服->客 也可以客->服

2. 没有同源限制，客户端可以与任意服务器通信。

3. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

4. 可以发送文本，也可以发送二进制数据。

5. 数据格式比较轻量，性能开销小，通信高效。

6. 协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。

   > ws://example.com:80/some/path



## DNS

根顶权

![image-20220225170741226](/Users/limohan/Library/Application Support/typora-user-images/image-20220225170741226.png)	 

## CDN 

内容分发网络

用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫**边缘节点**，其实就是缓存了源站内容的代理服务器。

应用`CDN`后，`DNS` 返回的不再是 `IP` 地址，而是一个`CNAME`(Canonical Name ) 别名记录，指向`CDN`的全局负载均衡

- 检查边缘节点的负载情况，找负载较轻的节点

结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问`CDN`的缓存代理

## TCP UDP

### 1. 区别

- TCP面向连接，UDP无连接
- TCP可靠，UDP不可靠
- TCP面向字节流， UDP面向报文
- TCP 1V1 UDP 1v1 1v多 多v多
- TCP首部20字节，UDP首部8字节

### 2. TCP如何保证可靠传输





### 3. 三次握手四次挥手





### 4. 为啥三次为啥四次

- 三次
  - 资源上
    - 为了防止服务器端开启一些无用的连接增加服务器开销 （可能第二次握手服务端发送的syn ack丢失了，客户端没有确认，服务端不知道就一直开着）（服务端的包丢了）
    - 防止已失效的连接请求报文段突然又传送到了服务端，服务端发送ACK，建立连接，但是客户端是关闭的，浪费资源 （瞎拿一个）

- 四次：当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

## Fetch axios ajax

前端向服务端发送请求,一般会使用三种方式,**XMLHttpRequest(XHR)**，**Fetch** ，jQuery实现的**AJAX**。

fetch发送2次请求的原因

- 第一次发送Options请求 看服务器是否支持该请求头
- 第二次发送真正请求


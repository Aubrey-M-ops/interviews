# 网络和浏览器

## 关于TCP UDP

- TCP 重传、滑动窗口、流量控制、拥塞控制

[TCP 重传、滑动窗口、流量控制、拥塞控制 - 简书 (jianshu.com)](https://www.jianshu.com/p/5b07a2f05771)

- 三次握手 四次握手

  [(2条消息) TCP三次握手和四次挥手全过程及为什么要三次握手解答_岩枭的博客-CSDN博客_tcp三次握手和四次挥手的全过程](https://blog.csdn.net/yanxiaolx/article/details/52123628)

## HTTP123

#### Http1.0

浏览器每次请求都需要与服务器建立一个TCP连接，处理完就断开

#### Http1.1

Keep-alive 长连接

管道传输（按顺序执行）

#### Http2.0

首部压缩

二进制分帧

多路复用

- http2的传输是基于二进制帧的
- 每一个TCP连接中承载了多个双向流通的流，每一个流都有一个独一无二的标识和优先级，而流就是由二进制帧组成的。
- 二进制帧的头部信息会标识自己属于哪一个流，所以这些帧是可以交错传输，然后在接收端通过帧头的信息组装成完整的数据。

#### http3.0

基于 UDP 的 QUIC 协议。建立持久连接、协商加密协议

## HTTP/HTTPS

- 区别

  - 加密
    - http传输的数据都是未加密的，也就是明文的
    - https通过SSL协议来对http协议传输的数据进行加密处理，可进行加密传输和身份认证

  - 端口
    - http协议的端口为80，https的端口为443
  - 费用
    - Https协议需要ca证书，费用较高。
  - 连接方式
    - http的连接很简单，是无状态的；
    - HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

- https工作原理

  - 客户端使用url访问服务器，要求建立ssl连接
  - web服务器收到请求后，将网站的证书返回给客户端（证书里包含公钥）
  - 客户端与服务端协商安全等级

  - 客户端浏览器通过安全等级建立会话密钥，通过公钥加密会话密钥，传送给未被服务器
  - web服务器通过自己的私钥解出会话密钥
  - web服务器通过会话密钥与客户端通信

- https优缺点
  - 优点
    - 认证用户和服务器，确保数据发送到正确的客户机和服务器；
    - 加密 安全
  - 缺点
    - 握手阶段比较费时，页面加载时间增长，耗电增多
    - 没有http高效
    - ssl证书需要钱
  
- http 2.0

  允许多路复用 在http1.1中，浏览器客户端在同一时间，针对同一域名下的**请求有一定数量限制**（连接数量），超过限制会被阻塞。

  #### 状态码

  200 请求成功

  201 已创建

  202 已接受

  - 已接受请求 但未处理完成

  204 无内容

  - 服务器成功处理，但未返回内容

  301 永久移动 （请求的资源永久移动到新的URI）

  302 临时移动

  304 未修改 

  - 如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容自上次访问并没有改变，则服务器应当返回这个304状态码。

  305 使用代理

  400 请求无效

  - 前端字段名称没有与后端保持一致
  - 前端没有把对象转化为json 

  401

  - 当前请求需要用户验证

  403

  - 服务器已经得到请求 但拒绝执行

  404 没有找到资源

## BOM

>  BOM是浏览器对象

- location对象
  - location.href-- 返回或设置当前文档的URL
  - location.search -- 返回URL中的查询字符串部分。
  - location.hash -- 返回URL#后面的内容，如果没有#，返回空
  - location.replace(url);
  - location.reload() -- 重载当前页面
- history对象
  - history.go() -- 前进或后退指定的页面数 history.go(num);
  - history.back() -- 后退一页
  - history.forward() -- 前进一页

## Cookie、sessionStorage、localStorage

> 共同点：都是保存在浏览器端，并且是同源的（协议、端口、host都相同）

#### cookie

HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

- 在过期前一直有效（保留数据，不需要重新登陆，保持登录状态/记录用户所在地区，不用每次重新定位）
- 在浏览器和服务器之间来回传递，始终在同源的HTTP请求中携带
- 存储大小很小（只有4k)
- 可以限制路径
- 所有同源窗口共享



- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

> cookie字段：
>
> name字段为一个cookie的名称。
>
> value字段为一个cookie的值。
>
> domain字段为可以访问此cookie的域名。name字段为一个cookie的名称。
>
> path可以访问cookie的页面路径
>
> secure 字段 设置是否只能通过https来传递此条cookie
>
> http字段 cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。
>
> Size字段此cookie大小。

`Cookie 编码方式：encodeURI()`

##### cookie如何防范XSS攻击

>  XSS（跨站脚本攻击）:攻击者在返回的HTML中嵌入js脚本

在http头部set-cookie

- httponly-禁止js脚本访问cookie
- secure - 仅在请求为https的时候发送cookie

#### cookie（通行证）和session（客户明细表）的区别

##### 为啥需要？

HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。

- cookie存储session id
- session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。

Cookie和session都可用来存储用户信息，cookie存放于客户端，session存放于服务器端

cookie存放于客户端有可能被窃取，所以**cookie一般用来存放不敏感**的信息，比如用户设置的网站主题.

用**session存储敏感**的信息，比如用户的登陆信息

##### **Session的实现原理：**

1）服务端首先查找对应的cookie的值（sessionid）
2）根据sessionid，从服务器端session存储中获取对应id的session数据，进行返回
3）如果找不到sessionid，服务器端就创建session，生成sessionid对应的cookie，写入到响应头中

##### **如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转？**

第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接`xxx?SessionID=123456...`。

第二种方案，Token 机制。当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。





>SessionStorage localStorage 仅在客户端中保存，不参与和服务器的通信

#### SessionStorage

- 浏览器窗口关闭就没了
- 不在不同浏览器窗口共享，即使是同一个页面

#### localStorage

- 浏览器窗口关闭也一直保存，是**永久数据**
- 所有同源窗口共享

## iframe

>  它能够将另一个HTML页面嵌入到当前页面中。

iframe和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。

## Fetch

前端向服务端发送请求,一般会使用三种方式, 

**XMLHttpRequest(XHR)**，**Fetch** ，jQuery实现的**AJAX**。

- fetch发送2次请求的原因
  - 第一次发送Options请求 看服务器是否支持该请求头
  - 第二次发送真正请求

## 强缓存、协商缓存

**浏览器缓存**是浏览器在**本地磁盘**对用户最近请求过的文档进行存储

**为了减少没必要的请求**

缓存分为**强缓存**和**协商缓存**



ETag 用于标识URL对象是否改变

## http首部

可以将http首部分为通用首部，请求首部，响应首部，实体首部

通用首部表示一些通用信息，比如date表示报文创建时间，

请求首部就是请求报文中独有的，如cookie，和缓存相关的如if-Modified-Since

响应首部就是响应报文中独有的，如set-cookie，和重定向相关的location，

实体首部用来描述实体部分，如allow用来描述可执行的请求方法，content-type描述主题类型，content-Encoding描述主体的编码方式

## SPA

https://www.jianshu.com/p/a02eb15d2d70

## CDN

内容分发网络

用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫**边缘节点**，其实就是缓存了源站内容的代理服务器。

应用`CDN`后，`DNS` 返回的不再是 `IP` 地址，而是一个`CNAME`(Canonical Name ) 别名记录，指向`CDN`的全局负载均衡

- 检查边缘节点的负载情况，找负载较轻的节点

结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问`CDN`的缓存代理

## DNS

根顶权

![image-20220225170741226](/Users/limohan/Library/Application Support/typora-user-images/image-20220225170741226.png)





## TCP为什么三次握手四次挥手

### 不能两次握手

- 为了防止服务器端开启一些无用的连接增加服务器开销 （可能第二次握手服务端发送的syn ack丢失了，客户端没有确认，服务端不知道就一直开着）（服务端的包丢了）
- 防止已失效的连接请求报文段突然又传送到了服务端，服务端发送ACK，建立连接，但是客户端是关闭的，浪费资源 （瞎拿一个）

### 必须四次挥手

当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。



## http握手

SSL 已经逐渐被 TLS 取代

 TLS 握手的过程中，通信双方交换消息以相互验证，相互确认，并确立它们所要使用的加密算法以及会话密钥 (用于对称加密的密钥)。

1. 客户端发送client_hello (询问) 包含了客户端所支持的 **TLS 版本**和**密码组合**以供服务器进行选择，还有一个"**client random**"随机字符串。
2. 服务端发送server_hello （返回协商信息） 该消息包含了**数字证书**，**服务器选择的密码组合**和"**server random**"随机字符串。
3. 客户端验证证书，确保对方合法身份，从中获取公钥，生成随机字符串**premaster secret**并用公钥进行加密并返回给服务端
4. 服务端使用私钥获取**premaster** **secret**，只有私钥能解密

5. 客户端服务端使用相同的算法，并使用client random  server random premaster secret生成相同的密钥key
6. 客户端发送通过key加密的finished
7. 服务端发送通过key加密的finished
8. 成功建立安全连接，用key通信



## OSI七层模型

应用层 http https

表示层 要负责数据格式的转换，确保一个系统的应用层发送的消息可以被另一个系统的应用层读

会话层 负责网络中两节点的建立 DNS

传输层 实现两个用户进程间端到端的可靠通信

网络层 逻辑地址寻址，寻找最佳网络路径

数据链路层 建立逻辑连接、进行硬件地址寻址，相邻的两个设备间的互相通信

物理层 物理介质传输媒介（网线或者是无线）

## websocket

1. 全双工 可以服->客 也可以客->服

2. 没有同源限制，客户端可以与任意服务器通信。

3. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

4. 可以发送文本，也可以发送二进制数据。

5. 数据格式比较轻量，性能开销小，通信高效。

6. 协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。

   > ws://example.com:80/some/path


# 面经汇总



## 作用域和作用域链

**作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。**

ES6之前 全局作用域，函数作用域，ES6之后块级作用域

全局：最外层函数和变量，windows的属性

函数：函数内部

内可以访问外，外不能访问内

块：let const 块外部不能访问 函数内部或代码块内部（花括号）

- 声明变量不会提升到代码块顶部



自由变量，运用值a，但是函数里没有定义a

函数中某个自由变量的取值，在创建函数的域中取，这就是所谓的"静态作用域"。

没有再找父级，依次向上，一层一层的关系就是作用域链



执行上下文（动态作用域）与静态作用域

js解释和执行两个阶段，作用域是解释阶段创建的，动态作用域是执行阶段创建的

动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从**何处调用**。

 **执行上下文在运行时确定，随时可能改变；静态（词法）作用域在定义时就确定，并且不会改变**。

## Function和Object的原型链关系

Object是Function的实例

但是function继承自object（图）

## 使用闭包每秒打印一个数字

```js
   let arr = [1, 2, 3, 4, 5]
    for (let i = 0; i < arr.length; i++) {
        (function (i) {
            setTimeout(() => {
                console.log(arr[i])
            }, i * 1000)
        })(i)
    } 
```

## for in 和 for of

for in可枚举属性 （对象的key）

For of可迭代对象  (数组的value)

## 判断数组类型

instance of

Constructor 

toString 

isArray



## Defer async

Async:不会阻塞浏览器，异步加载，加载完立刻执行

Defer：异步加载，**执行被推迟**。解析完dom，渲染之前执行

- 脚本与dom和其他脚本<u>依赖关系不强</u>时用async,脚本<u>依赖于 DOM 元素和其它脚本的执行结果</u>时，我们会选用 defer
- 有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。

## 

## Vue data 为什么是函数

每个vue组件都是vue实例，是new出来的

vue的data件原型上的属性，数据存在于内存当中

vue组件为了保证每个实例上的data数据的独立性，规定了必须使用函数，而不是对象。

## 为什么要有对称加密和非对称加密

对称加密：不能保证密钥安全发给对方

非对称：公钥谁都能拿，用来加密，只有私钥能解密，

非对称加密可以保证客户端传输给服务端的内容无法被“破解”，但服务端发给客户端的公钥和内容可能被截获

- 为什么要证书：无法证明拿到的公钥是正确的公钥，而不是被掉包的，因此需要证书证明这个公钥是可信赖的。接收方拿到证书后可以验证签名



**采用混合加密**

> 先通过非对称密钥加密对称密钥（证书验证阶段），通过对称密钥加密实际请求的内容（数据传输阶段）。
>
> 1. 服务端返回证书和公钥
> 2. 浏览器生成随机数，并用公钥加密
> 3. 服务端用私钥解密
> 4. 双方用该随机数对称加密进行通信

## http缓存

只存派生类文件（脚本 图片）

1. 内存缓存 `读取高效，但是缓存持续性短` 

   存当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等，会随着进程的释放而释放。 **一旦我们关闭 Tab 页面，内存中的缓存也就被释放了**

2. 磁盘缓存 `读取速度慢，但容量大，持续性长` 绝大部分的缓存都来自Disk Cache，在HTTP的协议头中设置。

   CSS

#### 访问缓存优先级

1. 先在内存中查找,如果有,直接加载。
2. 如果内存中不存在,则在硬盘中查找,如果有直接加载。
3. 如果硬盘中也没有,那么就进行网络请求。
4. 请求获取的资源缓存到硬盘和内存。

## 移动端和pc端的区别

1. PC考虑的是浏览器的兼容性，而移动端开发考虑的更多的是手机兼容性，移动端都是webkit
2. 移动端多出来触屏事件，PC端多出来hover事件
3. 移动端自适应布局

## 输入url到渲染

1. 缓存检查
2. DNS解析 （CDN）应用层
3. 建立TCP连接 （传输层）
4. 发送http请求 （ssl)
5. 服务器处理请求
6. 断开tcp连接
7. 浏览器解析并渲染相应内容
   1. 浏览器请求回来html
   2. 自上而下解析并构建dom
   3. 遇到css文件开启新线程，解析并构建cssom树
   4. html继续解析
   5. 遇到js发生阻塞，暂停DOM构建，等js下载并执行完
   6. DOM CSSOM 相结合
   7. 计算几何布局
   8. 绘制渲染树（样式变化时重绘，布局变化时重排）渲染树和dom树不是一一对应，例如head元素。另外，display属性为none的元素也不会在渲染树中出现


注意⚠️ JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。

​	顺序上

​	CSS 优先：引入顺序上，**CSS 资源先于 JavaScript 资源**。浏览器为了避免样式变化时重新渲染绘制页面元素，会阻塞内容逐步呈现，

​	JS置后：我们通常把JS代码放到页面底部，且JavaScript 应尽量少影响 DOM 的构建。





## 白屏优化

- 减少http请求消耗
  - CDN
  - 强缓存 协商缓存（只存派生类文件，比如图片脚本，不存主资源html）
  - 多用get少用post（get产生一个tcp数据包，post产生两个）
- 延迟加载
  - 非重要的库、非首屏图片延迟加载（用户滚动到它们之前，可视区域外的图像不会加载）
  - **vue-lazyload** **src属性直接改为v-lazy**
- 浏览器渲染减少阻塞



## JS垃圾回收

- 垃圾就是没有被引用的对象，需要被清除。有一个例外，如果几个对象引用形成一个环，互相引用，但是访问不到他们，这几个对象也是垃圾
- 基本的垃圾回收算法
  - “标记-清除”
    - 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
    - 然后从各个根对象开始遍历，把不是垃圾的节点改成1
    - 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
    - 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收
    - 优点：实现简单 缺点：清除之后剩余对象的内存位置不变，出现内存碎片，造成内存分配慢的问题 
  - 引用计数
    - 早先垃圾回收算法，现在很少用到
    - 记录每个变量被使用的次数
    - 声明一个变量并且将引用类型赋给变量时引用次数为1
    - 同一个值赋给另一个变量再加1，如果变量被其他值覆盖了，引用次数减一
    - 引用次数为0的时候被回收
    - 优点：标记清除算法每隔一段时间进行一次，JS运行过程中要暂停去执行GC，且要遍历，但引用计数只要引用时加一就可以了 缺点：需要计数器，占很大位置 且环型互相引用不会被清除，因为引用计数不为0

​	

## 三栏布局

1. 流体布局 （两边浮动定宽，中间用margin自适应）

2. BFC三栏布局（两边浮动定宽，中间BFC不会与浮动元素重叠）

缺点：主要内容无法最先加载，当页面内容较多时会影响用户体验。

3. 双飞翼布局
4. 圣杯布局
5. flex布局



## Vue keep-alive

**使被包含的组件保留状态，或避免重新渲染，也就是组件缓存**

App.vue中 v-if$route.meta.keepAlive，需要在`router`中设置router的元信息meta：



## ts声明文件

声明接口和类型信息



## XSS

在用户访问的网页中插入自己的脚本

## 表单请求

### 最原始

将`<form></form>`标签中的enctype设置为`multipart/form-data`就可以发送

### 使用ajax和FormData

Axios提交表单参数 

其请求内容格式为**Content-Type: multipart/form-data**



## 项目中icon svg

创建一个vue组件，表示svg-icon, 里面有props: 宽高，iconName，其中<use/>中设定href为iconName

新建一个svg文件夹，里面放入所有的.svg

将svg-icon注册为全局组件，用webpack中的require.context遍历svg文件夹中所有的.svg文件并自动导入，不用显式import

引用一个svg时，直接用<svg-icon>标签，iconName属性设置为文件名称



## 什么时候用vue.use()

取决于引用的组件有没有install方法，。当外界在 use 这个组件的时候，就会调用本身的 install 方法，

## 浏览器进程线程

> 控制进程、渲染进程、GPU进程

### 渲染进程（主要）

浏览器每打开一个页面就是一个进程，一个进程里有5个线程

1. GUI渲染线程 ：解析HTML，CSS，渲染页面 **GUI渲染线程与JS引擎线程是互斥的**
2. JS引擎线程 ： 等待任务队列中任务的到来，处理js **JS引擎是单线程的**
3. 事件触发线程: 控制事件循环
4. 定时器触发线程： setInterval与setTimeout
5. 异步http请求线程 ：将这个回调再放入事件队列中。再由JavaScript引擎执行。

### 控制进程和渲染进程

- Browser进程收到用户请求，获取内容，通过RendererHost接口传递给Render进程
- 渲染进程解析并渲染（5个线程），（GPU进程帮助渲染），将结果传递给控制进程
- 控制进程收到结果并绘制出来

### webworker

JS引擎是单线程的，而且JS执行时间过长会阻塞页面

- JS引擎可以向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM），JS引擎线程可以与worker线程之间通信

- 如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，只待计算出结果后，将结果通信给主线程即可，perfect!

### load事件与DOMContentLoaded事件

- `DOMContentLoaded` —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 `<img>` 和CSS之类的外部资源可能尚未加载完成。
- `load` —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。



## 前端体系结构

js+html+css => 一种前端框架（Vue）=> 浏览器工作原理 => 前端工程化（构建打包工具：webpack）=> 前端性能优化 => 前端安全 

## Git merge/rebase

把master合并到feature时

- git merge 会在 `feature` 分支中新增一个新的 **merge commit**，然后将两个分支的历史联系在一起

  - 如果master提交活跃，会污染提交历史记录

- rebase 会将master的提交记录续到feature上,特点是仍然会在`feature`分支上形成线性提交从而有效地整合了所有 master 分支上的提交。

  

- 融合代码到公共分支的时使用`git merge`,而不用`git rebase` （会导致别人再合的时候版本不一致，pull的时候需要合并，导致）
- 融合代码到个人分支的时候使用`git rebase`，可以不污染分支的提交记录，形成简洁的线性提交历史记录。

## 进程间是否共享内存？

## 



## 线程间如何通信



## webpack热更新



## localStorage跨域

postMessage和iframe相结合

domain1页面中

1. domain1页面里放一个domain2的iframe

2. ```js
    window.frames[0].postMessage('jogging, reading and writing','http://www.domain2.com'); //向iframe发送请求
   ```

Domain2页面中

```js
 window.addEventListener('message', function(e) {  
            if (e.source != window.parent)   
                return;  
            console.log(e.data);
            localStorage.setItem('task',e.data);

            window.parent.postMessage('finished', '*');  
        }, false);
```

## cookie对比token

### 有无状态

cookie 验证是**有状态的**，session需要一直在服务端和客户端保持,一旦用户登出，则 session 在客户端和服务器端都被销毁

- 将 session ID 放进 cookie 中，被存储在用户浏览器中。
- 再次发起请求，服务器直接通过 session ID 对用户进行验证
- 一旦用户登出，则 session 在客户端和服务器端都被销毁

token 验证是**无状态的**,后端不需要记录token

- 接着发起请求的时候将 token 放进 Authorization header
- 服务器端解码 JWT（编码方式`Base64URL`） 然后验证 token，如果 token 有效，则处理该请求。
- 一旦用户登出，token 在客户端被销毁，不需要经过服务器端。

### token优势

1. 跨域

token跨域只需要access-control-allow-headers:token

2. CSRF

3. 不需要经过服务器端，利于服务器分布式部署

### 使用场景

如果开发的系统足够小，用户少，倾向于使用 cookie/session，简单、易维护。

如果系统同时登录用户多，集群服务器多，则倾向于使用token，客户端可以将Token保存到任何地方，无限制，无状态，利于分布式部署。



## 订阅发布 观察者

- 观察者是经典软件`设计模式`中的一种，发布订阅是软件架构中的一种`消息范式`
- 组成：观察者2个角色（观察者、`被观察者`） 发布订阅三个角色（发布者、订阅者、`发布订阅中心`
  - 二者的关系是通过`被观察者主动`建立的,被观察者添加观察者，被观察者被触发通知所有观察者，二者`松耦合`
  - `发布者`把消息通知的权限交由`发布订阅中心`管理，`发布者`只需关心自身的`发布`逻辑，而不会直接和其所发布内容的`订阅者`直接通信。`订阅者`也如此。因此`发布者`和`订阅者`由于`发布订阅中心`的出现而完全解耦。

- `观察者模式`中的`被观察者`需要在每次自身改变后都绑定式地触发对`观察者`的通知，因为这是`观察者模式`这一模式所要实现的核心，而`发布订阅`与之的区别在于，因为`发布者`把消息通知的权限交由`发布订阅中心`管理，`发布者`只需关心自身的`发布`逻辑，而不会直接和其所发布内容的`订阅者`直接通信。



## class

### Constructor

类本身指向构造函数 **class的底层依然是function构造函数**。

类的公共方法都定义在类的prototype属性上

class的内部定义的方法都是不可枚举的（non-enumerable），这一点与ES5的行为不一致。

### new

ES5不new指向全局

ES6必须new

### static

只能类本身调用（定义在构造函数里）



## cookie samesite

防止csrf攻击

`Strict`最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie

`Lax`规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

## 

## fetch和axios的区别

- Axios是对XMLHttpRequest的封装，而Fetch是一种新的获取资源的接口方式，并不是对XMLHttpRequest的封装
- Fetch是浏览器原生支持，而Axios需要引入Axios库。
- 传递数据
  - fetch需要以字符串形式（JSON.stringify)
  - Axios直接传递对象（在内部转化为json字符串）

## Object和Map的区别

object只能用简单类型做键

Map类继承了Object，并对Object功能做了一些拓展

- 同名： map的键如果是引用类型，只要是两个不同的地址就是两个不同的键（即使名字相同）
- 可迭代：map可以用for of迭代，object不能迭代
- 长度：map可以用.size拿到长度，object不行
- 顺序：map按照插入的顺序，object按照字符串顺序
